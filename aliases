#[THIS IS ZSH or BASH]

########################################################################
# the zsh/bash functions that may be of interest to most folks:
########################################################################
# [git add ons]
#    dif
########################################################################
#
# [quick DB access -- be VERY careful and please treat DB as readonly]
#    pql
#    pql-nt
#    pql-x
# [quick JS cmd-line invocations]
#    no
#    nor
#    nop
# [syntax checking code]
#    lint
#
########################################################################
#
# Same file used in:
#  av/env/aliases  clusters/aliases  petabox/docker/aliases  www/docker/aliases  wold/scripts/aliases

[ "$THOME" = "" ] && export THOME=$(find /home/tracey /Users/tracey / -maxdepth 0 2>/dev/null |head -1)

# load other aliases (when full home dir)
FI=$THOME/petabox/sw/work/common.sh && [ -e $FI ] && source $FI
FI=$THOME/av/bin/aliases-tv         && [ -e $FI ] && source $FI

[ "$KUBERNETES_SERVICE_PORT_HTTPS" = "443" ]  &&  export TERM=xterm-color



function no-av() {
  # find location of repo - look for production, but replace with local, when both
  N=/av/www/js        &&  [ -e $N ]  &&  NODIR=$N
  N=$THOME/av/www/js  &&  [ -e $N ]  &&  NODIR=$N
  [ $NODIR ]  ||  return

  # now adjust that to the CWD we're in now
  NODIR=./$(realpath --relative-to=. $NODIR)

  echo "
import path from 'path'
import fs from 'fs'
import { existsSync, mkdirSync, readdirSync, readFileSync, realpathSync, renameSync } from 'fs'
import request from '$NODIR/../../node_modules/sync-request/lib/index.js'

import { ksort, krsort, str_replace, vsort, vrsort } from '$NODIR/util/strings.js'
import { log, fatal, warn, warnfull } from '$NODIR/util/log.js'
import { cmd, esc, exe, exePP, exePPW, execSync } from '$NODIR/util/cmd.js'
import { date, datetimeTZ, filemtime, strtotime, time, ymdhis, ymdhi } from '$NODIR/time.js'

import { https_request } from '$NODIR/https_request.js'

import search          from '$NODIR/tv/search.js'
import * as Str        from '$NODIR/util/strings.js'
import * as Tm         from '$NODIR/time.js'
import * as Config     from '$NODIR/util/config.js'
import * as EPG        from '$NODIR/tv/epg.js'
import TVC, * as TV    from '$NODIR/tv.js'
import * as News       from '$NODIR/tv/news.js'
import * as Recordings from '$NODIR/tv/recordings.js'
import * as Tuners     from '$NODIR/tv/tuners.js'
import * as Tasks      from '$NODIR/tv/tasks.js'
import ERR, * as Err   from '$NODIR/tv/err.js'
import * as Meta       from '$NODIR/tv/meta.js'

"
}

function no() {
  # like a smarter `node -e` that expects ES Modules and
  # pre-imports many of the most common 'av' CLI classes/methods (for convenience)
  (
    no-av
    echo "$@"
  ) | node --input-type=module
}


function nor() {
  # @see no() - this variant executes passed in JS code over each lint to stdin
  # example:
  #    nor  -B 'let sum=0'  -E 'log(sum)'  'sum += parseInt(line,10)'
  ARG=${1:?"Usage: nor [-B '<opt. init code>'] [-E '<opt. end code>'] [code run on each stdin line]"}
  [ "$1" = "-B" ]  &&  BEF="$2"  &&  shift  &&  shift
  [ "$1" = "-E" ]  &&  AFT="$2"  &&  shift  &&  shift

  node --input-type=module -e "
""$(no-av)""
import readline from 'readline'
""$BEF""
readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false})
  .on('line', (line) => {
    ""$@""
  })
  .on('close', () => {
    ""$AFT""
  })
"
}

function nop() {
  # @see no() - this variant is useful with HEREDOCs in shell aliases/functions (see examples below)
  export NOPTMP=$(mktemp)
  >| $NOPTMP # pipe stdin to "nop()" into this temp file
  ( no-av; cat $NOPTMP ) |node --input-type=module - "$@"
  rm -f $NOPTMP
}



# typical way to connect into DB (and alternate "n(o) t(ables)" way)
[ -z $DATABASE_URL ] && DATABASE_URL=postgres://archive:`/opt/.petabox/dbserver 2>/dev/null`@db-lb/archive
function pql() {
[ "$#" = 0 ] &&             psql $DATABASE_URL
[ "$#" = 0 ] || echo "$@" | psql $DATABASE_URL
}
function pql-nt() { # "No Tables" ascii art
[ "$#" = 0 ] &&             psql $DATABASE_URL -tAF'	'
[ "$#" = 0 ] || echo "$@" | psql $DATABASE_URL -tAF'	'
}
function pql-x() { # table columns vertically
[ "$#" = 0 ] &&             psql $DATABASE_URL -x
[ "$#" = 0 ] || echo "$@" | psql $DATABASE_URL -x
}





alias lesscolored="colordiff | less -R"
alias ciff=colordiff

[ $UNAME ]  ||  UNAME=$(uname) # eg: mac

if [ "$UNAME" != "alpine" ]; then
  # make e/f/grep see red!
  # ugh, ubuntu/unix sometimes you just suck... (old -v- new UNFRIENDLY way):
  # export GREP_OPTIONS=" --color=AUTO "
  alias  grep=" grep --color"
  alias egrep="egrep --color"
  alias fgrep="fgrep --color"
fi


ttl() {
  if [ "$#" == "0" ]; then
    echo "Usage: ttl some title you want ..."
    return
  fi

  echo -n -e "\033]0;""$@""\007"
}
ttlhost() { ttl $(hostname -s); }



# these env vars are arrays, that's right
typeset -a TV RD1 DOCK

PET=$(find $HOME/petabox /petabox $THOME/petabox -maxdepth 0 2>/dev/null |head -1)
AV=$(find $HOME/av /av $THOME/av -maxdepth 0 2>/dev/null |head -1)
COMP=$PET/components
COMMON=$PET/www/common
WWW=$PET/www/sf
IN=$WWW/includes

  TV=( $(zsh -c "typeset -a F; F=(
$IN/less/*.less
$COMP/tv/*js
$COMP/play8/*js
$COMP/archive/*.js
$COMMON/{Details,Video,Player,Maps,Graph,Nav,TV}.inc
$COMMON/TV[A-QS-Z]*
$WWW/tv*.php
$WWW/{details,download}.php
$WWW/services/{maker,borrow}.php
$AV/lib/extracTS/extracTS.c
$AV/lib/extracTS/utils.c
$PET/tv/*.php
$PET/tv/stats/parse.php
$PET/tv/911about.htm
$PET/etc/cron.d/{homenodes,tv*,rm-old-files}
$PET/etc/systemd/system/tv*
$PET/www/datanode/tvNRT.php
$PET/tv/bin/*
$PET/deriver/inc/NRT.php
$PET/sw/work/fixer.php
) 2>/dev/null; (
  find \$F -type d -prune -o -type f -print 2>/dev/null
  find $AV -type f -name json -prune -o -name build -prune -o -name test -prune -o -name .git -prune -o -name lib -prune -o -name node_modules -prune -o -type f -print
) |tr '\n' ' '") )

  RD1=( $(zsh -c "typeset -a F; F=(
$COMMON/{Details,Facet,Imager,Item,Lists,Metadata,Nav,Search,SearchBar,*Search/*,Tile,Tiles,TilesWrap,Timegraf,Video,Graph,Player}.inc
$COMMON/setup.php
$WWW/{details,collection,index,search,account/index}.php
$WWW/services/{exit.php,post-file.php,views.php}
$IN/less/*.less
$COMP/{archive,tv,play8,playset}/*.js
) 2>/dev/null; (
  find \$F -type d -prune -o -type f -print 2>/dev/null
) |tr '\n' ' '") )

  DOCK=( $(zsh -c "typeset -a F; F=(
$PET/.gitlab-ci.yml
$PET/chart/*
$PET/Dockerfile
$PET/bin/install.sh
$HOME/kre8/*
$HOME/kre8/*/*
$HOME/kre8/*/*/*
$HOME/other/notes.md
$HOME/.aliases
) 2>/dev/null; (
  find \$F -type d -prune -o -type f -print 2>/dev/null
  find $PET/docker -maxdepth 2 -type f -print
) |tr '\n' ' '") )

unset PET WWW IN COMP COMMON



function chopper2() {
  if [ -e /usr/bin/node  -o  -e /usr/local/bin/node ]; then
    nor '
const COL = parseInt(process.env.COLUMNS, 10)
const PAD = Math.min(COL - 20, 90)
if (line.length < COL) {
  log(line)
} else {
  log(line.slice(0, COL))
  line = line.slice(COL)
  do {
    log(`${" ".repeat(PAD)}${line.slice(0, COL - PAD)}`)
    line = line.slice(COL - PAD)
  } while (line.length)
}'
  else
    cat
  fi
}


if [ "$UNAME" != "alpine"  -a  "$UNAME" != "Darwin" ]; then
  alias   ps='ps --columns "$COLUMNS"'
fi

psf(){ ps fauxwww; }
psc(){ psf | grep --devices=read "$@" | chopper | grep "$@"; }
pscc(){ psc -C${NUM-5} "$@" | grep -v -- devices=read | grep -C${NUM-5} "$@"; }
pscx(){ psf | grep --devices=read -C${NUM-5} "$@" | grep -v -- devices=read | grep -C${NUM-5} "$@" | chopper2 | grep -C10000 "$@"; }
#pscx like pscc but smarter "chopper"


ipaddy(){
  [ "$#" = "1" ]  &&  host "$1" | perl -ane 'print $F[3] if $F[2] eq "address"'
  [ "$#" = "0" ]  &&  ifconfig eth0 | grep 'inet addr' | sed 's/\sBcast.*$//' | sed 's/.*inet addr://' | sed 's/\s//g' 2>/dev/null
}


# last 2 args make it _not_ page if the content is < 1 vertical screen
export LESS='-R -F -X'


alias   df="df -k"
alias   du="du -k"
alias   ls="ls -F"

alias        l="avoid problems later"
alias       ll="avoid problems later"
unalias      l
unalias     ll



function anotb() {
  if [ "$#" != "2" ]; then
    echo "Usage: <sorted file> <sorted file>"
    return
  fi

  sort -c "$1"  &&  sort -c "$2"  &&  join -v 1 "$1" "$2"
}


function cgi_args_to_array() {
  nor "log(Object.fromEntries(line.split('&').map((e) => decodeURIComponent(e).split('='))))"
}

function args() {
  if [ "$#" != "1" ]; then
    echo "usage: args <task_id>"
    return
  else
    # remove anything before "=" sign in case arg was pasted in
    # from logfile link like:
    # http://archive.org/log_show.php?task_id=1927468
    task_id=`echo "$1" | cut -f 2 -d =`
  fi
  # check catalog first.  ONLY check catalog_done if not in catalog
  pql-nt SELECT args FROM catalog      WHERE task_id=$task_id         |cgi_args_to_array |egrep . ||
  pql-nt SELECT args FROM catalog_done WHERE task_id=$task_id LIMIT 1 |cgi_args_to_array |egrep .
}



############################################################################################
# php and petabox stuff
############################################################################################
function rm-derivs() {
  id=$(basename `pwd`)
  if [ ! -e ${id}_files.xml ]; then
    echo "NO FILES.XML MAKING ONE..."
    echo '<files/>' > ${id}_files.xml
  fi
  phpr '$f=new FilesXML("'`pwd`'"); $f->delete_derived_files("{*,*/*,*/*/*}");'
  fx # prune (now) stale entries from _files.xml
}

function rederive() {
  id=$(basename `pwd`)
  if [ -d "/home/tracey" ]; then
    export PETABOX_HOME=/home/tracey/petabox
  else
    PETABOX_HOME=/petabox
  fi
  if [ ! -e "${id}_meta.xml" ]; then
    echo; echo; echo NOTE FAKING _meta.xml; echo; echo
    echo '<metadata><collection>opensource_movies</collection></metadata>' > ${id}_meta.xml
  fi

  rm-derivs
  echo '<files/>' >| ${id}_files.xml
  fx
  $PETABOX_HOME/deriver/derive.php
}

function fx() { phpr 'FilesXML::setFormats(null,"PRUNE");'; }

function show-originals-and-derivs () {
	phpr 'EditFixer::show_originals_and_derivs();' "$@"
}
############################################################################################
# php and petabox stuff
############################################################################################




function files() {
  dirs="$@"
  [ "$#" = "0" ]  &&  dirs=.
  find "$dirs" -type f 2>&1 |fgrep -v .git/ 2>&1 |sort
}

function files+() {
  (
    files "$@"
    find "$dirs" -type l -print0 \
      |xargs -0 ${GSTAT?} --format %N \
      |perl -pe 's/^.//; s/.$//; s/. \-> ./\t->\t/'
  ) |sort
}




#################################################################################
#   VERSION CONTROL FUNCTIONS
#################################################################################

giss()  {   git status -s .; }
gitnix(){ rm "$@"; git checkout "$@"; }
dif()   { ( git --no-pager diff "$@" )  ||  ( svn diff --no-diff-deleted "$@" | colordiff ); }
dif20() {   git --no-pager diff -U20 "$@"; }
gg()    {   git --no-pager grep -I "$@" -- './*' ':!*\.min\.js' ':!*\.min\.js\.map'; }
prevdiff(){ git log -n1 $1 |cat; line; git --no-pager diff $(git log -n2 --pretty=format:"%h" $1|tail -1) $1; }

#################################################################################
#   VERSION CONTROL FUNCTIONS
#################################################################################




add       (){ perl -p -e '$ tot += $ _; s@.*@$ tot@;'; }


boxx      (){ LIKE=$1; shift; pql "SELECT node,location,alias,mate,kind,rank,flow,zone,attr,duty FROM box WHERE zone='US' "$@" AND (node LIKE '%$LIKE%' OR location LIKE '%$LIKE%')ORDER BY node"; }
box2      (){ LIKE=$1; shift; pql "SELECT node,location,alias,ip,fqhostname,mate,hardware,kind,rank,rack,cdx,server,flow,zone,attr,duty FROM box WHERE zone='$ZONE' "$@" AND (node LIKE '%$LIKE%' OR location LIKE '%$LIKE%') AND NOT (node LIKE 'switch%' OR node LIKE 'pdu%') ORDER BY location" |perl -ape '$x=$F[3];chop($x);chop($x);print "-------RACK $x-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n" if ($x  &&  $x ne $prev); $prev=$x;'; }
box3      (){
  hosts=$(pql-nt 'SELECT * FROM box' |egrep "$@" |perl -F'\t' -ane 'print "$F[4]\n";' |killspace |quotem)
  set -x
  pql 'SELECT * FROM box WHERE node IN ('$hosts') ORDER BY node'
  set +x
}
boxall    (){
  pql "SELECT node,location,alias,mate,kind,rank,flow,zone,attr,workmax,duty,nagios,site FROM box ORDER BY node"
}




bnota     (){ anotb "$2" "$1"; }
chopper   (){ CN=$1; if [ "$#" != "1" ]; then CN=$COLUMNS; fi; perl -pe "$ f = chop; $ _ = substr($ _, 0, $CN) . $ f"; }
col       (){ perl -pe '$ | = 1; s/^\s+//; s/\t/ /g; tr/ //s' | cut -d ' ' -f "$@"; }
collast   (){ perl -ane 'print pop(@F) . chop;' "$@"; }

countdot  (){ if [ "$#" = "0" ]; then find . -type f |fgrep -v /.git/ |perl -ne 'print $1 if m=\.([^\.]+$)=' |sort |uniq -c; else find "$@" -type f |fgrep -v /.git/ |perl -ne 'print $1 if m=\.([^\.]+$)=' |sort |uniq -c;  fi; }


function files() {
  dirs="$@"
  [ "$#" = "0" ]  &&  dirs=.
  find "$dirs" -type f 2>&1 |fgrep -v .git/ 2>&1 |sort
}

GSTAT=$([ -e /usr/local/bin/gstat ] && echo gstat || echo stat) # ternary
function files+() {
  (
    files "$@"
    find "$dirs" -type l -print0 \
      |xargs -0 ${GSTAT?} --format %N \
      |perl -pe 's/^.//; s/.$//; s/. \-> ./\t->\t/'
  ) |sort
}

finddot   (){ dot=$1; shift; find . -name "*.$dot" "$@"; }

hist      (){ cat $HOME/.*history*; history; }


# Removes lead and trailing whitespace; compresses interline whitespace; filters out "whitespace only" lines
killr     (){ perl -p -i -e "tr/\r//d" "$@"; }
killspace (){ perl -ne 's/\s*(\n)//; $ f = $ 1; s/^\s+//; s/\s+/ /g;  next unless m/./; print; print $ f ;'; }
l         (){ ls -A -F -l "$@"; }
lc        (){ wc -l "$@"; }
list      (){ m `which $1`; }
listem    (){ tr '\n' ' ' | perl -pe chop; }

lt        (){ /bin/ls -A -F -l -tr "$@"; }
lh        (){ /bin/ls -FAltrh "$@"; }
m         (){ less "$@"; }
me        (){ NUM=0; pscc $USER; unset NUM; }

purge     (){ rm -f \#*\# .*~ *~ ~/.*~; }
quotem    (){ perl -ne 'chop; print "\x27$_\x27"; print "," unless eof();'; }

rdiff     (){ diff -x .git -x "*#*" -x "*~" -r "$@"; }
real      (){ H=$HOME; if [ "$HOME" = "/root" ]; then H=/home/tracey; fi; source $H/.aliases; }
reverse   (){ perl -ane 'print join(" ",reverse(@F)), chop' ; }

# screen is a buzzkill when it hijacks my CTL-A!
scr() {
  pre=pooh;
  if [ "$#" = "0" ]; then
    export SCREENNUM=1;
  else
    export SCREENNUM=$1;
    if $(echo $SCREENNUM |egrep -q '[a-z]' ); then
      pre=;
    fi
  fi;
  env TERM=xterm /usr/bin/screen -e^Oo -xRR -S $pre$SCREENNUM;
}



trim      (){ nor "log(line.replace(/</g,'&lt;').replace(/>/g,'&gt;').trim())"; }
wgeto     (){ wget -O - "$@"; }
zero      (){ echo -n | sudo tee "$1" 2>/dev/null; }

function ssh-keyblip() {
  HO=${1:?"Usage: [hostname] # removes hostname from $HOME/.ssh/known_hosts"}
  ssh-keygen -f $HOME/.ssh/known_hosts -R ${HO?}
}


function user() {
  echo "SELECT * FROM users WHERE itemname='$1' OR username='$1'" |pql-x
}


function dbm() {
  echo "SELECT * FROM metadata WHERE identifier='$1'" |pql-x
}


function db()  {
  # allows cmdline query/arg to look like a task_id (int) OR task log like:
  #   http://catalogd.archive.org/log/23104744
  ARG="$1"

  # if all digits, switch to /log/###..
  tmp=$(echo "$ARG" |tr -d '0-9')
  [ "$tmp" = "" ]  &&  ARG="/log/$ARG"

  # anything matching ../log/###.. is a task
  TID=$(echo "$ARG" |egrep -o '/log/[0-9][0-9][0-9]+' |tr -d '/log')
  tmp=$(echo "$TID" |tr -d '0-9')
  if [ "$TID" != ""  -a  "$tmp" = "" ]; then
    echo "SELECT * FROM catalog      WHERE task_id=$TID" |pql-x
    echo "SELECT * FROM catalog_done WHERE task_id=$TID" |pql-x
  else
    ID=$(basename "$ARG" |cut -f1 -d'?' |cut -f1 -d'&') # in case /details/ url, etc.
    echo "
WITH r AS (
  SELECT * FROM catalog      WHERE identifier='$ID'
)
SELECT * FROM r
UNION ALL
  SELECT * FROM catalog_done WHERE identifier='$ID'
AND NOT EXISTS (
  SELECT * FROM r
)" |pql-x
  fi
}
